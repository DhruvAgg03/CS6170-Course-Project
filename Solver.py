# -*- coding: utf-8 -*-
"""VLSI_LP_Formulation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12Ev1BC9dBWChCnt4Zg91Agvegyfd6uJ_
"""
DEBUG = False

# Import the Pyomo library, which can be installed via pip, conda or from Github https://github.com/Pyomo/pyomo
import pyomo.environ as pyo
# Import Matplotlib to generate plots
import matplotlib.pyplot as plt
# Import numpy and scipy for certain numerical calculations
import numpy as np
from scipy.special import gamma
import math
import random
import math

# Let's install the LP/MIP solvers GLPK and CBC
opt_cbc = pyo.SolverFactory('cbc')

n = 0 #lattice nxn read from .txt file
net = [] # net[i] = list(tree indices) for ith net
tree = [] # tree[j] = list(edge indices) for jth tree
edge = {} # edge["u_v"] = list(tree indices)
all_edges = [] #List of all edges
num_nets = 0
trees_per_net = 0

def dprint(x):
    if DEBUG:
        print(x)

def cellnum(i, j):
  global n
  return i*n + j

def tr2ind(t): #convert 1d ind of tree to 2d
  global trees_per_net
  #dprint(trees_per_net)
  #dprint(t//trees_per_net , t%trees_per_net)
  return t//trees_per_net , t%trees_per_net

def parseFile(fileName):
  global n, net, tree, edge, all_edges, num_nets, trees_per_net
  n = 0 #lattice nxn read from .txt file
  net = [] # net[i] = list(tree indices) for ith net
  tree = [] # tree[j] = list(edge indices) for jth tree
  edge = {} # edge["u_v"] = list(tree indices)
  all_edges = [] #List of all edges
  num_nets = 0
  trees_per_net = 0
  # Open the file in read mode
  with open(fileName, 'r',  encoding='utf-8') as file:
      # Iterate through each line in the file
      Lines = file.readlines()
      cnt = 0
      treecnt = 0
      for line in Lines:
          # Process each line as needed
          nums = line.strip().split()
          for i in range(len(nums)):
            nums[i] = int(nums[i])

          if(cnt == 0):
            n = nums[0]
            dprint(n)
          elif(cnt == 1):
            num_nets = nums[0]
            dprint(num_nets)
          elif(cnt == 2):
            trees_per_net = nums[0]
            dprint(trees_per_net)
          else:
            if(len(nums) == 1):
              treecnt += 1
              tree.append([])
            else:
              x = str(cellnum(nums[0], nums[1]))
              y = str(cellnum(nums[2], nums[3]))
              e = x + "_" + y
              tree[len(tree) - 1].append(e)
              if e not in edge:
                edge[e] = []
              edge[e].append(len(tree) - 1)

          cnt += 1

def solver(fileName, mode):
  global n, net, tree, edge, all_edges, num_nets, trees_per_net
  parseFile(fileName)
  dprint(edge)

  #Net number
  net_num = [j for j in range(num_nets)]

  #total number of tree indicator variables for the ith net
  net_len = [i for i in range(trees_per_net)]
  dprint(trees_per_net)

  all_edges = [e for e in edge]

  # Define the model
  model = pyo.ConcreteModel(name='Binary_LPSolver')
  #Define the variables
  if(mode == 0):
    model.x = pyo.Var(net_num, net_len, domain=pyo.Binary)
  else:
    model.x = pyo.Var(net_num, net_len, domain=pyo.Reals, bounds=(0, 1))

  model.b = pyo.Var(all_edges, domain=pyo.Binary)
  if(mode == 0):
    model.u = pyo.Var(domain=pyo.NonNegativeIntegers) #stores max of edge weights
    model.w = pyo.Var(all_edges, domain=pyo.NonNegativeIntegers)
    model.M = num_nets # can just be num_nets
  else:
    model.u = pyo.Var(domain=pyo.Reals) #stores max of edge weights
    model.w = pyo.Var(all_edges, domain=pyo.Reals)
    model.M = num_nets # can just be num_nets

  dprint(model.M)
  model.constraints = pyo.ConstraintList()
  model.obj = pyo.Objective(expr=model.u, sense=pyo.minimize)
  # Define the constraints
  for i in range(num_nets):
    model.constraints.add(sum(model.x[i, j] for j in range(trees_per_net)) == 1)

  for e in all_edges:
    tree_ind = []
    for t in edge[e]:
      i, j = tr2ind(t)
      tree_ind.append([i, j])
    model.constraints.add(sum(model.x[t[0], t[1]] for t in tree_ind) == model.w[e])
    model.constraints.add(model.u >= model.w[e])
    model.constraints.add(model.u <= model.w[e] + (1 - model.b[e])*model.M)

  model.constraints.add(sum(model.b[e] for e in all_edges) == 1)


  #[model.constraints.add(sum(model.A[row][col] * model.x[col] for col in range(len(C))) == model.b[row]) for row in range(len(b))]
  dprint(len(model.constraints))

  # dPrint the model
  #model.pprint()

  #Solver
  result_obj = opt_cbc.solve(model, tee=DEBUG)

  #model.x = pyo.Var(net_num, net_len, domain=pyo.Binary)
  solns = [[pyo.value(model.x[i, j]) for j in range(trees_per_net)] for i in range(num_nets)]
  cost = pyo.value(model.u)
  dprint(solns)
  dprint(cost)
  return cost, solns

def maxWeight(m, fileName):
  global n, net, tree, edge, all_edges, num_nets, trees_per_net
  parseFile(fileName)
  nets = num_nets
  tpn = trees_per_net
  wts = {}
  for i in range(nets):
    for j in range(tpn):
      if(m[i][j] == 1):
        tnum = i*tpn + j
        for e in tree[tnum]:
          if e not in wts:
            wts[e] = 0
          wts[e] += 1

  cost = 0
  for e in wts:
    cost = max(cost, wts[e])

  return cost



